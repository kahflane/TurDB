//! # SQL Token Definitions
//!
//! This module defines the token types produced by the SQL lexer. The design
//! prioritizes zero-copy operation - string tokens borrow directly from the
//! input SQL string rather than allocating new strings.
//!
//! ## Token Categories
//!
//! Tokens are organized into several categories:
//!
//! - **Keywords**: Reserved SQL words (SELECT, FROM, WHERE, etc.)
//! - **Identifiers**: Table names, column names, aliases
//! - **Literals**: Strings, numbers, booleans, null
//! - **Operators**: Comparison, arithmetic, logical, JSON, array operators
//! - **Punctuation**: Parentheses, brackets, comma, semicolon, etc.
//! - **Special**: Parameters, comments, whitespace, EOF, errors
//!
//! ## Zero-Copy Design
//!
//! All string-like tokens use `&'a str` slices that point directly into the
//! original input string. This eliminates allocation during lexing and allows
//! the lexer to process SQL at maximum speed.
//!
//! ```text
//! Input:  "SELECT name FROM users"
//!          ^^^^^^ ^^^^ ^^^^ ^^^^^
//!          |      |    |    |
//!          |      |    |    Token::Ident("users")
//!          |      |    Token::Keyword(Keyword::From)
//!          |      Token::Ident("name")
//!          Token::Keyword(Keyword::Select)
//! ```
//!
//! ## Span Information
//!
//! Each token carries span information (byte offset and length) for error
//! reporting. The Span struct is Copy and cheap to pass around.
//!
//! ## Operator Precedence
//!
//! The lexer does not handle operator precedence - that's the parser's job.
//! However, multi-character operators like `>=`, `<>`, `->` are tokenized
//! as single tokens to simplify parsing.
//!
//! ## Error Handling
//!
//! Invalid input produces `Token::Error` with a descriptive message and span.
//! The lexer attempts to recover and continue tokenizing after errors.
//!
//! ## Usage
//!
//! ```ignore
//! use turdb::sql::{Lexer, Token, Keyword};
//!
//! let mut lexer = Lexer::new("SELECT * FROM users");
//! assert_eq!(lexer.next_token(), Token::Keyword(Keyword::Select));
//! assert_eq!(lexer.next_token(), Token::Star);
//! assert_eq!(lexer.next_token(), Token::Keyword(Keyword::From));
//! assert_eq!(lexer.next_token(), Token::Ident("users"));
//! assert_eq!(lexer.next_token(), Token::Eof);
//! ```

use std::fmt;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Span {
    pub offset: u32,
    pub len: u32,
}

impl Span {
    pub fn new(offset: usize, len: usize) -> Self {
        Self {
            offset: offset as u32,
            len: len as u32,
        }
    }

    pub fn start(&self) -> usize {
        self.offset as usize
    }

    pub fn end(&self) -> usize {
        (self.offset + self.len) as usize
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Token<'a> {
    Keyword(Keyword),
    Ident(&'a str),
    QuotedIdent(&'a str),
    String(&'a str),
    Integer(&'a str),
    Float(&'a str),
    HexNumber(&'a str),
    BinaryNumber(&'a str),
    OctalNumber(&'a str),
    Parameter(Parameter<'a>),

    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Caret,
    Ampersand,
    Pipe,
    DoublePipe,
    Tilde,
    LeftShift,
    RightShift,
    Hash,

    Eq,
    NotEq,
    Lt,
    LtEq,
    Gt,
    GtEq,
    Spaceship,

    Arrow,
    DoubleArrow,
    HashArrow,
    HashDoubleArrow,
    AtGt,
    LtAt,
    DoubleAmpersand,
    Question,
    QuestionPipe,
    QuestionAmpersand,

    LParen,
    RParen,
    LBracket,
    RBracket,
    LBrace,
    RBrace,
    Comma,
    Semicolon,
    Colon,
    DoubleColon,
    Dot,
    DoubleDot,
    Assign,
    FatArrow,

    Eof,
    Error(&'a str),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Parameter<'a> {
    Positional(u32),
    Named(&'a str),
    Anonymous,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Keyword {
    // DDL
    Create,
    Alter,
    Drop,
    Truncate,
    Add,
    Column,
    Rename,

    // DML
    Select,
    Insert,
    Update,
    Delete,
    Merge,
    Upsert,

    // Query clauses
    From,
    Where,
    Group,
    Having,
    Order,
    Limit,
    Offset,
    Fetch,
    By,
    As,

    // Joins
    Join,
    Inner,
    Left,
    Right,
    Full,
    Outer,
    Cross,
    Natural,
    On,
    Using,

    // Set operations
    Union,
    Intersect,
    Except,
    All,
    Distinct,

    // Subquery keywords
    In,
    Exists,
    Any,
    Some,

    // CTE
    With,
    Recursive,

    // Transaction
    Begin,
    Commit,
    Rollback,
    Savepoint,
    Release,

    // Constraints
    Primary,
    Foreign,
    Key,
    References,
    Unique,
    Check,
    Not,
    Null,
    Default,
    Cascade,
    Restrict,
    Set,

    // Index
    Index,
    Btree,
    Hash,
    Gin,
    Gist,
    Hnsw,

    // Types
    Integer,
    Int,
    Bigint,
    Smallint,
    Tinyint,
    Real,
    Double,
    Decimal,
    Numeric,
    Varchar,
    Char,
    Text,
    Blob,
    Boolean,
    Bool,
    Date,
    Time,
    Timestamp,
    Timestamptz,
    Interval,
    Uuid,
    Json,
    Jsonb,
    Vector,
    Array,

    // Procedural
    Function,
    Procedure,
    Returns,
    Language,
    Declare,
    End,
    If,
    Then,
    Else,
    Elsif,
    While,
    Loop,
    For,
    Return,
    Call,
    Execute,

    // Explain/Analyze
    Explain,
    Analyze,
    Verbose,
    Costs,
    Buffers,
    Timing,
    Format,

    // Schema objects
    Schema,
    Database,
    Table,
    View,
    Materialized,
    Trigger,
    Sequence,
    Type,
    Enum,
    Domain,

    // Misc
    Case,
    When,
    Cast,
    Collate,
    Like,
    Ilike,
    Similar,
    Between,
    Is,
    True,
    False,
    And,
    Or,
    Asc,
    Desc,
    Nulls,
    First,
    Last,
    Over,
    Partition,
    Window,
    Rows,
    Range,
    Unbounded,
    Preceding,
    Following,
    Current,
    Row,
    Values,
    Into,
    Returning,
    Conflict,
    Do,
    Nothing,
    Replace,
    Ignore,
    Constraint,
    Only,
    Lateral,
    Ordinality,
    Within,
    Filter,
    Respect,
    Precision,
    Zone,
    Varying,
    Without,
    Data,
    Authorization,
    Owned,
    Temporary,
    Temp,
    Unlogged,
    Logged,
    Concurrently,
    Nowait,
    Skip,
    Locked,
    Share,
    Exclusive,
    Access,
    No,
    Action,
    Match,
    Partial,
    Simple,
    Generated,
    Always,
    Identity,
    Overriding,
    System,
    User,
    Value,
    Stored,
    Virtual,
    Exclude,
    Including,
    Excluding,
    Comments,
    Statistics,
    Storage,
    Compression,
    Indexes,
    Constraints,
    Defaults,
    Deferrable,
    Initially,
    Deferred,
    Immediate,
    Enable,
    Disable,
    Replica,
    Rule,
    Event,
    Instead,
    Each,
    Statement,
    Before,
    After,
    Referencing,
    Old,
    New,
    Assertion,
    Normalize,
    Work,
    Transaction,
    Isolation,
    Level,
    Read,
    Write,
    Committed,
    Uncommitted,
    Repeatable,
    Serializable,
    Snapshot,
    Local,
    Session,
    Global,
    Cluster,
    Reindex,
    Vacuum,
    Discard,
    Plans,
    Sequences,
    Reset,
    Show,
    Grant,
    Revoke,
    To,
    Option,
    Admin,
    Inherit,
    Noinherit,
    Login,
    Nologin,
    Replication,
    Bypassrls,
    Nobypassrls,
    Connection,
    Createdb,
    Nocreatedb,
    Createrole,
    Nocreaterole,
    Superuser,
    Nosuperuser,
    Password,
    Valid,
    Until,
    Role,
    Roles,
    Member,
    Public,
    Schema2,
    Tables,
    Functions,
    Procedures,
    Types,
    Sequences2,
    Privileges,
    Usage,
    Copy,
    Binary,
    Csv,
    Header,
    Quote,
    Escape,
    Delimiter,
    Encoding,
    Force,
    Freeze,
    Stdin,
    Stdout,
    Program,
    Import,
    Export,
    Verbose2,
    Abort,
    Absolute,
    Allocate,
    Are,
    Asensitive,
    Asymmetric,
    At,
    Atomic,
    Blob2,
    Called,
    Cardinality,
    Cascaded,
    Character,
    Clob,
    Close,
    Collect,
    Condition,
    Contains,
    Convert,
    Corresponding,
    Cube,
    Cursor,
    Cycle,
    Day,
    Deallocate,
    Dec,
    Describe,
    Deterministic,
    Disconnect,
    Dynamic,
    Element,
    Elseif,
    Equals,
    Every,
    Exec,
    Exit,
    External,
    Free,
    Get,
    Go,
    Grouping,
    Handler,
    Hold,
    Hour,
    Indicator,
    Input,
    Insensitive,
    Inout,
    Iterate,
    Large,
    Lateral2,
    Leading,
    Leave,
    Localtime,
    Localtimestamp,
    Method,
    Minute,
    Modifies,
    Module,
    Month,
    Multiset,
    National,
    Nchar,
    Nclob,
    None,
    Object,
    Of,
    Open,
    Out,
    Output,
    Parameter2,
    Prepare,
    Reads,
    Ref,
    Relative,
    Result,
    Rollup,
    Savepoint2,
    Scope,
    Scroll,
    Search,
    Second,
    Sensitive,
    Sets,
    Specific,
    Specifictype,
    Sql,
    Sqlexception,
    Sqlstate,
    Sqlwarning,
    Start,
    Static,
    Submultiset,
    Symmetric,
    Tablesample,
    Timezone,
    Trailing,
    Treat,
    Uescape,
    Undo,
    Unknown,
    Unnest,
    Year,
}

impl Keyword {
    pub fn as_str(&self) -> &'static str {
        match self {
            Keyword::Create => "CREATE",
            Keyword::Alter => "ALTER",
            Keyword::Drop => "DROP",
            Keyword::Truncate => "TRUNCATE",
            Keyword::Add => "ADD",
            Keyword::Column => "COLUMN",
            Keyword::Rename => "RENAME",
            Keyword::Select => "SELECT",
            Keyword::Insert => "INSERT",
            Keyword::Update => "UPDATE",
            Keyword::Delete => "DELETE",
            Keyword::Merge => "MERGE",
            Keyword::Upsert => "UPSERT",
            Keyword::From => "FROM",
            Keyword::Where => "WHERE",
            Keyword::Group => "GROUP",
            Keyword::Having => "HAVING",
            Keyword::Order => "ORDER",
            Keyword::Limit => "LIMIT",
            Keyword::Offset => "OFFSET",
            Keyword::Fetch => "FETCH",
            Keyword::By => "BY",
            Keyword::As => "AS",
            Keyword::Join => "JOIN",
            Keyword::Inner => "INNER",
            Keyword::Left => "LEFT",
            Keyword::Right => "RIGHT",
            Keyword::Full => "FULL",
            Keyword::Outer => "OUTER",
            Keyword::Cross => "CROSS",
            Keyword::Natural => "NATURAL",
            Keyword::On => "ON",
            Keyword::Using => "USING",
            Keyword::Union => "UNION",
            Keyword::Intersect => "INTERSECT",
            Keyword::Except => "EXCEPT",
            Keyword::All => "ALL",
            Keyword::Distinct => "DISTINCT",
            Keyword::In => "IN",
            Keyword::Exists => "EXISTS",
            Keyword::Any => "ANY",
            Keyword::Some => "SOME",
            Keyword::With => "WITH",
            Keyword::Recursive => "RECURSIVE",
            Keyword::Begin => "BEGIN",
            Keyword::Commit => "COMMIT",
            Keyword::Rollback => "ROLLBACK",
            Keyword::Savepoint => "SAVEPOINT",
            Keyword::Release => "RELEASE",
            Keyword::Primary => "PRIMARY",
            Keyword::Foreign => "FOREIGN",
            Keyword::Key => "KEY",
            Keyword::References => "REFERENCES",
            Keyword::Unique => "UNIQUE",
            Keyword::Check => "CHECK",
            Keyword::Not => "NOT",
            Keyword::Null => "NULL",
            Keyword::Default => "DEFAULT",
            Keyword::Cascade => "CASCADE",
            Keyword::Restrict => "RESTRICT",
            Keyword::Set => "SET",
            Keyword::Index => "INDEX",
            Keyword::Btree => "BTREE",
            Keyword::Hash => "HASH",
            Keyword::Gin => "GIN",
            Keyword::Gist => "GIST",
            Keyword::Hnsw => "HNSW",
            Keyword::Integer => "INTEGER",
            Keyword::Int => "INT",
            Keyword::Bigint => "BIGINT",
            Keyword::Smallint => "SMALLINT",
            Keyword::Tinyint => "TINYINT",
            Keyword::Real => "REAL",
            Keyword::Double => "DOUBLE",
            Keyword::Decimal => "DECIMAL",
            Keyword::Numeric => "NUMERIC",
            Keyword::Varchar => "VARCHAR",
            Keyword::Char => "CHAR",
            Keyword::Text => "TEXT",
            Keyword::Blob => "BLOB",
            Keyword::Boolean => "BOOLEAN",
            Keyword::Bool => "BOOL",
            Keyword::Date => "DATE",
            Keyword::Time => "TIME",
            Keyword::Timestamp => "TIMESTAMP",
            Keyword::Timestamptz => "TIMESTAMPTZ",
            Keyword::Interval => "INTERVAL",
            Keyword::Uuid => "UUID",
            Keyword::Json => "JSON",
            Keyword::Jsonb => "JSONB",
            Keyword::Vector => "VECTOR",
            Keyword::Array => "ARRAY",
            Keyword::Function => "FUNCTION",
            Keyword::Procedure => "PROCEDURE",
            Keyword::Returns => "RETURNS",
            Keyword::Language => "LANGUAGE",
            Keyword::Declare => "DECLARE",
            Keyword::End => "END",
            Keyword::If => "IF",
            Keyword::Then => "THEN",
            Keyword::Else => "ELSE",
            Keyword::Elsif => "ELSIF",
            Keyword::While => "WHILE",
            Keyword::Loop => "LOOP",
            Keyword::For => "FOR",
            Keyword::Return => "RETURN",
            Keyword::Call => "CALL",
            Keyword::Execute => "EXECUTE",
            Keyword::Explain => "EXPLAIN",
            Keyword::Analyze => "ANALYZE",
            Keyword::Verbose => "VERBOSE",
            Keyword::Costs => "COSTS",
            Keyword::Buffers => "BUFFERS",
            Keyword::Timing => "TIMING",
            Keyword::Format => "FORMAT",
            Keyword::Schema => "SCHEMA",
            Keyword::Database => "DATABASE",
            Keyword::Table => "TABLE",
            Keyword::View => "VIEW",
            Keyword::Materialized => "MATERIALIZED",
            Keyword::Trigger => "TRIGGER",
            Keyword::Sequence => "SEQUENCE",
            Keyword::Type => "TYPE",
            Keyword::Enum => "ENUM",
            Keyword::Domain => "DOMAIN",
            Keyword::Case => "CASE",
            Keyword::When => "WHEN",
            Keyword::Cast => "CAST",
            Keyword::Collate => "COLLATE",
            Keyword::Like => "LIKE",
            Keyword::Ilike => "ILIKE",
            Keyword::Similar => "SIMILAR",
            Keyword::Between => "BETWEEN",
            Keyword::Is => "IS",
            Keyword::True => "TRUE",
            Keyword::False => "FALSE",
            Keyword::And => "AND",
            Keyword::Or => "OR",
            Keyword::Asc => "ASC",
            Keyword::Desc => "DESC",
            Keyword::Nulls => "NULLS",
            Keyword::First => "FIRST",
            Keyword::Last => "LAST",
            Keyword::Over => "OVER",
            Keyword::Partition => "PARTITION",
            Keyword::Window => "WINDOW",
            Keyword::Rows => "ROWS",
            Keyword::Range => "RANGE",
            Keyword::Unbounded => "UNBOUNDED",
            Keyword::Preceding => "PRECEDING",
            Keyword::Following => "FOLLOWING",
            Keyword::Current => "CURRENT",
            Keyword::Row => "ROW",
            Keyword::Values => "VALUES",
            Keyword::Into => "INTO",
            Keyword::Returning => "RETURNING",
            Keyword::Conflict => "CONFLICT",
            Keyword::Do => "DO",
            Keyword::Nothing => "NOTHING",
            Keyword::Replace => "REPLACE",
            Keyword::Ignore => "IGNORE",
            Keyword::Constraint => "CONSTRAINT",
            Keyword::Only => "ONLY",
            Keyword::Lateral => "LATERAL",
            Keyword::Ordinality => "ORDINALITY",
            Keyword::Within => "WITHIN",
            Keyword::Filter => "FILTER",
            Keyword::Respect => "RESPECT",
            Keyword::Precision => "PRECISION",
            Keyword::Zone => "ZONE",
            Keyword::Varying => "VARYING",
            Keyword::Without => "WITHOUT",
            Keyword::Data => "DATA",
            Keyword::Authorization => "AUTHORIZATION",
            Keyword::Owned => "OWNED",
            Keyword::Temporary => "TEMPORARY",
            Keyword::Temp => "TEMP",
            Keyword::Unlogged => "UNLOGGED",
            Keyword::Logged => "LOGGED",
            Keyword::Concurrently => "CONCURRENTLY",
            Keyword::Nowait => "NOWAIT",
            Keyword::Skip => "SKIP",
            Keyword::Locked => "LOCKED",
            Keyword::Share => "SHARE",
            Keyword::Exclusive => "EXCLUSIVE",
            Keyword::Access => "ACCESS",
            Keyword::No => "NO",
            Keyword::Action => "ACTION",
            Keyword::Match => "MATCH",
            Keyword::Partial => "PARTIAL",
            Keyword::Simple => "SIMPLE",
            Keyword::Generated => "GENERATED",
            Keyword::Always => "ALWAYS",
            Keyword::Identity => "IDENTITY",
            Keyword::Overriding => "OVERRIDING",
            Keyword::System => "SYSTEM",
            Keyword::User => "USER",
            Keyword::Value => "VALUE",
            Keyword::Stored => "STORED",
            Keyword::Virtual => "VIRTUAL",
            Keyword::Exclude => "EXCLUDE",
            Keyword::Including => "INCLUDING",
            Keyword::Excluding => "EXCLUDING",
            Keyword::Comments => "COMMENTS",
            Keyword::Statistics => "STATISTICS",
            Keyword::Storage => "STORAGE",
            Keyword::Compression => "COMPRESSION",
            Keyword::Indexes => "INDEXES",
            Keyword::Constraints => "CONSTRAINTS",
            Keyword::Defaults => "DEFAULTS",
            Keyword::Deferrable => "DEFERRABLE",
            Keyword::Initially => "INITIALLY",
            Keyword::Deferred => "DEFERRED",
            Keyword::Immediate => "IMMEDIATE",
            Keyword::Enable => "ENABLE",
            Keyword::Disable => "DISABLE",
            Keyword::Replica => "REPLICA",
            Keyword::Rule => "RULE",
            Keyword::Event => "EVENT",
            Keyword::Instead => "INSTEAD",
            Keyword::Each => "EACH",
            Keyword::Statement => "STATEMENT",
            Keyword::Before => "BEFORE",
            Keyword::After => "AFTER",
            Keyword::Referencing => "REFERENCING",
            Keyword::Old => "OLD",
            Keyword::New => "NEW",
            Keyword::Assertion => "ASSERTION",
            Keyword::Normalize => "NORMALIZE",
            Keyword::Work => "WORK",
            Keyword::Transaction => "TRANSACTION",
            Keyword::Isolation => "ISOLATION",
            Keyword::Level => "LEVEL",
            Keyword::Read => "READ",
            Keyword::Write => "WRITE",
            Keyword::Committed => "COMMITTED",
            Keyword::Uncommitted => "UNCOMMITTED",
            Keyword::Repeatable => "REPEATABLE",
            Keyword::Serializable => "SERIALIZABLE",
            Keyword::Snapshot => "SNAPSHOT",
            Keyword::Local => "LOCAL",
            Keyword::Session => "SESSION",
            Keyword::Global => "GLOBAL",
            Keyword::Cluster => "CLUSTER",
            Keyword::Reindex => "REINDEX",
            Keyword::Vacuum => "VACUUM",
            Keyword::Discard => "DISCARD",
            Keyword::Plans => "PLANS",
            Keyword::Sequences => "SEQUENCES",
            Keyword::Reset => "RESET",
            Keyword::Show => "SHOW",
            Keyword::Grant => "GRANT",
            Keyword::Revoke => "REVOKE",
            Keyword::To => "TO",
            Keyword::Option => "OPTION",
            Keyword::Admin => "ADMIN",
            Keyword::Inherit => "INHERIT",
            Keyword::Noinherit => "NOINHERIT",
            Keyword::Login => "LOGIN",
            Keyword::Nologin => "NOLOGIN",
            Keyword::Replication => "REPLICATION",
            Keyword::Bypassrls => "BYPASSRLS",
            Keyword::Nobypassrls => "NOBYPASSRLS",
            Keyword::Connection => "CONNECTION",
            Keyword::Createdb => "CREATEDB",
            Keyword::Nocreatedb => "NOCREATEDB",
            Keyword::Createrole => "CREATEROLE",
            Keyword::Nocreaterole => "NOCREATEROLE",
            Keyword::Superuser => "SUPERUSER",
            Keyword::Nosuperuser => "NOSUPERUSER",
            Keyword::Password => "PASSWORD",
            Keyword::Valid => "VALID",
            Keyword::Until => "UNTIL",
            Keyword::Role => "ROLE",
            Keyword::Roles => "ROLES",
            Keyword::Member => "MEMBER",
            Keyword::Public => "PUBLIC",
            Keyword::Schema2 => "SCHEMA",
            Keyword::Tables => "TABLES",
            Keyword::Functions => "FUNCTIONS",
            Keyword::Procedures => "PROCEDURES",
            Keyword::Types => "TYPES",
            Keyword::Sequences2 => "SEQUENCES",
            Keyword::Privileges => "PRIVILEGES",
            Keyword::Usage => "USAGE",
            Keyword::Copy => "COPY",
            Keyword::Binary => "BINARY",
            Keyword::Csv => "CSV",
            Keyword::Header => "HEADER",
            Keyword::Quote => "QUOTE",
            Keyword::Escape => "ESCAPE",
            Keyword::Delimiter => "DELIMITER",
            Keyword::Encoding => "ENCODING",
            Keyword::Force => "FORCE",
            Keyword::Freeze => "FREEZE",
            Keyword::Stdin => "STDIN",
            Keyword::Stdout => "STDOUT",
            Keyword::Program => "PROGRAM",
            Keyword::Import => "IMPORT",
            Keyword::Export => "EXPORT",
            Keyword::Verbose2 => "VERBOSE",
            Keyword::Abort => "ABORT",
            Keyword::Absolute => "ABSOLUTE",
            Keyword::Allocate => "ALLOCATE",
            Keyword::Are => "ARE",
            Keyword::Asensitive => "ASENSITIVE",
            Keyword::Asymmetric => "ASYMMETRIC",
            Keyword::At => "AT",
            Keyword::Atomic => "ATOMIC",
            Keyword::Blob2 => "BLOB",
            Keyword::Called => "CALLED",
            Keyword::Cardinality => "CARDINALITY",
            Keyword::Cascaded => "CASCADED",
            Keyword::Character => "CHARACTER",
            Keyword::Clob => "CLOB",
            Keyword::Close => "CLOSE",
            Keyword::Collect => "COLLECT",
            Keyword::Condition => "CONDITION",
            Keyword::Contains => "CONTAINS",
            Keyword::Convert => "CONVERT",
            Keyword::Corresponding => "CORRESPONDING",
            Keyword::Cube => "CUBE",
            Keyword::Cursor => "CURSOR",
            Keyword::Cycle => "CYCLE",
            Keyword::Day => "DAY",
            Keyword::Deallocate => "DEALLOCATE",
            Keyword::Dec => "DEC",
            Keyword::Describe => "DESCRIBE",
            Keyword::Deterministic => "DETERMINISTIC",
            Keyword::Disconnect => "DISCONNECT",
            Keyword::Dynamic => "DYNAMIC",
            Keyword::Element => "ELEMENT",
            Keyword::Elseif => "ELSEIF",
            Keyword::Equals => "EQUALS",
            Keyword::Every => "EVERY",
            Keyword::Exec => "EXEC",
            Keyword::Exit => "EXIT",
            Keyword::External => "EXTERNAL",
            Keyword::Free => "FREE",
            Keyword::Get => "GET",
            Keyword::Go => "GO",
            Keyword::Grouping => "GROUPING",
            Keyword::Handler => "HANDLER",
            Keyword::Hold => "HOLD",
            Keyword::Hour => "HOUR",
            Keyword::Indicator => "INDICATOR",
            Keyword::Input => "INPUT",
            Keyword::Insensitive => "INSENSITIVE",
            Keyword::Inout => "INOUT",
            Keyword::Iterate => "ITERATE",
            Keyword::Large => "LARGE",
            Keyword::Lateral2 => "LATERAL",
            Keyword::Leading => "LEADING",
            Keyword::Leave => "LEAVE",
            Keyword::Localtime => "LOCALTIME",
            Keyword::Localtimestamp => "LOCALTIMESTAMP",
            Keyword::Method => "METHOD",
            Keyword::Minute => "MINUTE",
            Keyword::Modifies => "MODIFIES",
            Keyword::Module => "MODULE",
            Keyword::Month => "MONTH",
            Keyword::Multiset => "MULTISET",
            Keyword::National => "NATIONAL",
            Keyword::Nchar => "NCHAR",
            Keyword::Nclob => "NCLOB",
            Keyword::None => "NONE",
            Keyword::Object => "OBJECT",
            Keyword::Of => "OF",
            Keyword::Open => "OPEN",
            Keyword::Out => "OUT",
            Keyword::Output => "OUTPUT",
            Keyword::Parameter2 => "PARAMETER",
            Keyword::Prepare => "PREPARE",
            Keyword::Reads => "READS",
            Keyword::Ref => "REF",
            Keyword::Relative => "RELATIVE",
            Keyword::Result => "RESULT",
            Keyword::Rollup => "ROLLUP",
            Keyword::Savepoint2 => "SAVEPOINT",
            Keyword::Scope => "SCOPE",
            Keyword::Scroll => "SCROLL",
            Keyword::Search => "SEARCH",
            Keyword::Second => "SECOND",
            Keyword::Sensitive => "SENSITIVE",
            Keyword::Sets => "SETS",
            Keyword::Specific => "SPECIFIC",
            Keyword::Specifictype => "SPECIFICTYPE",
            Keyword::Sql => "SQL",
            Keyword::Sqlexception => "SQLEXCEPTION",
            Keyword::Sqlstate => "SQLSTATE",
            Keyword::Sqlwarning => "SQLWARNING",
            Keyword::Start => "START",
            Keyword::Static => "STATIC",
            Keyword::Submultiset => "SUBMULTISET",
            Keyword::Symmetric => "SYMMETRIC",
            Keyword::Tablesample => "TABLESAMPLE",
            Keyword::Timezone => "TIMEZONE",
            Keyword::Trailing => "TRAILING",
            Keyword::Treat => "TREAT",
            Keyword::Uescape => "UESCAPE",
            Keyword::Undo => "UNDO",
            Keyword::Unknown => "UNKNOWN",
            Keyword::Unnest => "UNNEST",
            Keyword::Year => "YEAR",
        }
    }
}

impl fmt::Display for Keyword {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> fmt::Display for Token<'a> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Token::Keyword(kw) => write!(f, "{}", kw),
            Token::Ident(s) => write!(f, "{}", s),
            Token::QuotedIdent(s) => write!(f, "\"{}\"", s),
            Token::String(s) => write!(f, "'{}'", s),
            Token::Integer(s) => write!(f, "{}", s),
            Token::Float(s) => write!(f, "{}", s),
            Token::HexNumber(s) => write!(f, "0x{}", s),
            Token::BinaryNumber(s) => write!(f, "0b{}", s),
            Token::OctalNumber(s) => write!(f, "0o{}", s),
            Token::Parameter(p) => match p {
                Parameter::Positional(n) => write!(f, "${}", n),
                Parameter::Named(name) => write!(f, ":{}", name),
                Parameter::Anonymous => write!(f, "?"),
            },
            Token::Plus => write!(f, "+"),
            Token::Minus => write!(f, "-"),
            Token::Star => write!(f, "*"),
            Token::Slash => write!(f, "/"),
            Token::Percent => write!(f, "%"),
            Token::Caret => write!(f, "^"),
            Token::Ampersand => write!(f, "&"),
            Token::Pipe => write!(f, "|"),
            Token::DoublePipe => write!(f, "||"),
            Token::Tilde => write!(f, "~"),
            Token::LeftShift => write!(f, "<<"),
            Token::RightShift => write!(f, ">>"),
            Token::Hash => write!(f, "#"),
            Token::Eq => write!(f, "="),
            Token::NotEq => write!(f, "<>"),
            Token::Lt => write!(f, "<"),
            Token::LtEq => write!(f, "<="),
            Token::Gt => write!(f, ">"),
            Token::GtEq => write!(f, ">="),
            Token::Spaceship => write!(f, "<=>"),
            Token::Arrow => write!(f, "->"),
            Token::DoubleArrow => write!(f, "->>"),
            Token::HashArrow => write!(f, "#>"),
            Token::HashDoubleArrow => write!(f, "#>>"),
            Token::AtGt => write!(f, "@>"),
            Token::LtAt => write!(f, "<@"),
            Token::DoubleAmpersand => write!(f, "&&"),
            Token::Question => write!(f, "?"),
            Token::QuestionPipe => write!(f, "?|"),
            Token::QuestionAmpersand => write!(f, "?&"),
            Token::LParen => write!(f, "("),
            Token::RParen => write!(f, ")"),
            Token::LBracket => write!(f, "["),
            Token::RBracket => write!(f, "]"),
            Token::LBrace => write!(f, "{{"),
            Token::RBrace => write!(f, "}}"),
            Token::Comma => write!(f, ","),
            Token::Semicolon => write!(f, ";"),
            Token::Colon => write!(f, ":"),
            Token::DoubleColon => write!(f, "::"),
            Token::Dot => write!(f, "."),
            Token::DoubleDot => write!(f, ".."),
            Token::Assign => write!(f, ":="),
            Token::FatArrow => write!(f, "=>"),
            Token::Eof => write!(f, "EOF"),
            Token::Error(msg) => write!(f, "ERROR: {}", msg),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn span_new_and_accessors() {
        let span = Span::new(10, 5);
        assert_eq!(span.offset, 10);
        assert_eq!(span.len, 5);
        assert_eq!(span.start(), 10);
        assert_eq!(span.end(), 15);
    }

    #[test]
    fn token_display() {
        assert_eq!(format!("{}", Token::Keyword(Keyword::Select)), "SELECT");
        assert_eq!(format!("{}", Token::Ident("users")), "users");
        assert_eq!(format!("{}", Token::QuotedIdent("Order")), "\"Order\"");
        assert_eq!(format!("{}", Token::String("hello")), "'hello'");
        assert_eq!(format!("{}", Token::Integer("42")), "42");
        assert_eq!(format!("{}", Token::Float("3.14")), "3.14");
        assert_eq!(format!("{}", Token::Plus), "+");
        assert_eq!(format!("{}", Token::DoublePipe), "||");
        assert_eq!(format!("{}", Token::Arrow), "->");
        assert_eq!(format!("{}", Token::Eof), "EOF");
    }

    #[test]
    fn keyword_as_str() {
        assert_eq!(Keyword::Select.as_str(), "SELECT");
        assert_eq!(Keyword::From.as_str(), "FROM");
        assert_eq!(Keyword::Where.as_str(), "WHERE");
        assert_eq!(Keyword::Insert.as_str(), "INSERT");
        assert_eq!(Keyword::Update.as_str(), "UPDATE");
        assert_eq!(Keyword::Delete.as_str(), "DELETE");
    }

    #[test]
    fn parameter_display() {
        assert_eq!(
            format!("{}", Token::Parameter(Parameter::Positional(1))),
            "$1"
        );
        assert_eq!(
            format!("{}", Token::Parameter(Parameter::Named("name"))),
            ":name"
        );
        assert_eq!(format!("{}", Token::Parameter(Parameter::Anonymous)), "?");
    }
}
